{"version":3,"file":"createSharedClientContext.js","names":["PalantirApiError","createFetchHeaderMutator","createFetchOrThrow","createRetryingFetch","createSharedClientContext","baseUrl","tokenProvider","userAgent","fetchFn","fetch","length","Error","retryingFetchWithAuthOrThrow","headers","token","set","get","filter","x","join","input","init","e","betterError","message","errorName","errorCode","statusCode","errorInstanceId","parameters","cause"],"sources":["createSharedClientContext.js"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PalantirApiError } from \"@osdk/shared.net.errors\";\nimport { createFetchHeaderMutator, createFetchOrThrow, createRetryingFetch, } from \"@osdk/shared.net.fetch\";\nexport function createSharedClientContext(baseUrl, tokenProvider, userAgent, fetchFn = fetch) {\n    const ontology = { metadata: { userAgent: \"\" } };\n    if (baseUrl.length === 0) {\n        throw new Error(\"baseUrl cannot be empty\");\n    }\n    const retryingFetchWithAuthOrThrow = createFetchHeaderMutator(createRetryingFetch(createFetchOrThrow(fetchFn)), async (headers) => {\n        const token = await tokenProvider();\n        headers.set(\"Authorization\", `Bearer ${token}`);\n        headers.set(\"Fetch-User-Agent\", [\n            headers.get(\"Fetch-User-Agent\"),\n            userAgent,\n        ].filter(x => x && x?.length > 0).join(\" \"));\n        return headers;\n    });\n    // because this is async await it preserves stack traces, which the retrying fetch does not\n    const fetchWrapper = async (input, init) => {\n        try {\n            return await retryingFetchWithAuthOrThrow(input, init);\n        }\n        catch (e) {\n            const betterError = (e instanceof PalantirApiError)\n                ? new PalantirApiError(e.message, e.errorName, e.errorCode, e.statusCode, e.errorInstanceId, e.parameters)\n                : new Error(\"Captured stack trace for error: \" + e.message ?? e);\n            betterError.cause = e;\n            throw betterError;\n        }\n    };\n    return {\n        baseUrl,\n        fetch: fetchWrapper,\n        tokenProvider,\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,wBAAwB,EAAEC,kBAAkB,EAAEC,mBAAmB,QAAS,wBAAwB;AAC3G,OAAO,SAASC,yBAAyBA,CAACC,OAAO,EAAEC,aAAa,EAAEC,SAAS,EAAEC,OAAO,GAAGC,KAAK,EAAE;EAE1F,IAAIJ,OAAO,CAACK,MAAM,KAAK,CAAC,EAAE;IACtB,MAAM,IAAIC,KAAK,CAAC,yBAAyB,CAAC;EAC9C;EACA,MAAMC,4BAA4B,GAAGX,wBAAwB,CAACE,mBAAmB,CAACD,kBAAkB,CAACM,OAAO,CAAC,CAAC,EAAE,MAAOK,OAAO,IAAK;IAC/H,MAAMC,KAAK,GAAG,MAAMR,aAAa,CAAC,CAAC;IACnCO,OAAO,CAACE,GAAG,CAAC,eAAe,EAAE,UAAUD,KAAK,EAAE,CAAC;IAC/CD,OAAO,CAACE,GAAG,CAAC,kBAAkB,EAAE,CAC5BF,OAAO,CAACG,GAAG,CAAC,kBAAkB,CAAC,EAC/BT,SAAS,CACZ,CAACU,MAAM,CAACC,CAAC,IAAIA,CAAC,IAAIA,CAAC,EAAER,MAAM,GAAG,CAAC,CAAC,CAACS,IAAI,CAAC,GAAG,CAAC,CAAC;IAC5C,OAAON,OAAO;EAClB,CAAC,CAAC;EACF;;EAaA,OAAO;IACHR,OAAO;IACPI,KAAK,EAdY,MAAAA,CAAOW,KAAK,EAAEC,IAAI,KAAK;MACxC,IAAI;QACA,OAAO,MAAMT,4BAA4B,CAACQ,KAAK,EAAEC,IAAI,CAAC;MAC1D,CAAC,CACD,OAAOC,CAAC,EAAE;QACN,MAAMC,WAAW,GAAID,CAAC,YAAYtB,gBAAgB,GAC5C,IAAIA,gBAAgB,CAACsB,CAAC,CAACE,OAAO,EAAEF,CAAC,CAACG,SAAS,EAAEH,CAAC,CAACI,SAAS,EAAEJ,CAAC,CAACK,UAAU,EAAEL,CAAC,CAACM,eAAe,EAAEN,CAAC,CAACO,UAAU,CAAC,GACxG,IAAIlB,KAAK,CAAC,kCAAkC,GAAGW,CAAC,CAACE,OAAO,IAAIF,CAAC,CAAC;QACpEC,WAAW,CAACO,KAAK,GAAGR,CAAC;QACrB,MAAMC,WAAW;MACrB;IACJ,CAGuB;IACnBjB;EACJ,CAAC;AACL","ignoreList":[]}