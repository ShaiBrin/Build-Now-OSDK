/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { __EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks, __EXPERIMENTAL__NOT_SUPPORTED_YET__preexistingObjectSet, __EXPERIMENTAL__NOT_SUPPORTED_YET_subscribe } from "@osdk/api/unstable";
import { symbolClientContext as oldSymbolClientContext } from "@osdk/shared.client";
import { symbolClientContext } from "@osdk/shared.client2";
import { createBulkLinksAsyncIterFactory } from "./__unstable/createBulkLinksAsyncIterFactory.js";
import { applyAction } from "./actions/applyAction.js";
import { additionalContext } from "./Client.js";
import { createMinimalClient } from "./createMinimalClient.js";
import { fetchMetadataInternal } from "./fetchMetadata.js";
import { createObjectSet, getWireObjectSet } from "./objectSet/createObjectSet.js";
import { ObjectSetListenerWebsocket } from "./objectSet/ObjectSetListenerWebsocket.js";
import { applyQuery } from "./queries/applyQuery.js";
class ActionInvoker {
  constructor(clientCtx, actionDef) {
    // We type the property as a generic function as binding `applyAction`
    // doesn't return a type thats all that useful anyway
    // The implements covers us for the most part here as this exact type doesn't
    // escape this file
    this.applyAction = applyAction.bind(undefined, clientCtx, actionDef);
    this.batchApplyAction = applyAction.bind(undefined, clientCtx, actionDef);
  }
  applyAction;
  batchApplyAction;
}
class QueryInvoker {
  constructor(clientCtx, queryDef) {
    this.executeFunction = applyQuery.bind(undefined, clientCtx, queryDef);
  }
  executeFunction;
}
/** @internal */
export function createClientInternal(objectSetFactory,
// first so i can bind
baseUrl, ontologyRid, tokenProvider, options = undefined, fetchFn = fetch) {
  const clientCtx = createMinimalClient({
    ontologyRid
  }, baseUrl, tokenProvider, options, fetchFn, objectSetFactory);
  const fetchMetadata = fetchMetadataInternal.bind(undefined, clientCtx);
  const client = Object.defineProperties(function (o) {
    if (o.type === "object" || o.type === "interface") {
      return objectSetFactory(o, clientCtx);
    } else if (o.type === "action") {
      return new ActionInvoker(clientCtx, o); // then as any for dealing with the conditional return value
    } else if (o.type === "query") {
      return new QueryInvoker(clientCtx, o);
    } else if (o.type === "experiment") {
      switch (o.name) {
        case __EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks.name:
          return {
            getBulkLinks: createBulkLinksAsyncIterFactory(clientCtx)
          };
        case __EXPERIMENTAL__NOT_SUPPORTED_YET__preexistingObjectSet.name:
          return {
            preexistingObjectSet: (definition, rid) => {
              return createObjectSet(definition, client[additionalContext], {
                type: "intersect",
                objectSets: [{
                  type: "base",
                  objectType: definition.apiName
                }, {
                  type: "reference",
                  reference: rid
                }]
              });
            }
          };
        case __EXPERIMENTAL__NOT_SUPPORTED_YET_subscribe.name:
          return {
            subscribe: (objectSet, listener) => {
              const pendingSubscribe = ObjectSetListenerWebsocket.getInstance(clientCtx).subscribe(getWireObjectSet(objectSet), listener);
              return async () => (await pendingSubscribe)();
            }
          };
      }
      throw new Error("not implemented");
    } else {
      throw new Error("not implemented");
    }
  }, {
    [oldSymbolClientContext]: {
      value: clientCtx
    },
    [symbolClientContext]: {
      value: clientCtx
    },
    [additionalContext]: {
      value: clientCtx
    },
    fetchMetadata: {
      value: fetchMetadata
    }
  });
  return client;
}
export const createClient = createClientInternal.bind(undefined, createObjectSet);
//# sourceMappingURL=createClient.js.map