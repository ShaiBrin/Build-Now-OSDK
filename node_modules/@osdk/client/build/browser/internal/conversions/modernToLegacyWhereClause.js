/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { DistanceUnitMapping } from "@osdk/api";
import invariant from "tiny-invariant";
export function extractNamespace(fqApiName) {
  const last = fqApiName.lastIndexOf(".");
  if (last === -1) return [undefined, fqApiName];
  return [fqApiName.slice(0, last), fqApiName.slice(last + 1)];
}
/** @internal */
export function modernToLegacyWhereClause(whereClause, objectOrInterface) {
  if ("$and" in whereClause) {
    return {
      type: "and",
      value: whereClause.$and.map(clause => modernToLegacyWhereClause(clause, objectOrInterface))
    };
  } else if ("$or" in whereClause) {
    return {
      type: "or",
      value: whereClause.$or.map(clause => modernToLegacyWhereClause(clause, objectOrInterface))
    };
  } else if ("$not" in whereClause) {
    return {
      type: "not",
      value: modernToLegacyWhereClause(whereClause.$not, objectOrInterface)
    };
  }
  const parts = Object.entries(whereClause);
  if (parts.length === 1) {
    return handleWherePair(parts[0], objectOrInterface);
  }
  return {
    type: "and",
    value: parts.map(v => handleWherePair(v, objectOrInterface))
  };
}
function makeGeoFilterBbox(field, bbox, filterType) {
  return {
    type: filterType === "$within" ? "withinBoundingBox" : "intersectsBoundingBox",
    field,
    value: {
      topLeft: {
        type: "Point",
        coordinates: [bbox[0], bbox[3]]
      },
      bottomRight: {
        type: "Point",
        coordinates: [bbox[2], bbox[1]]
      }
    }
  };
}
function makeGeoFilterPolygon(field, coordinates, filterType) {
  return {
    type: filterType,
    field,
    value: {
      type: "Polygon",
      coordinates
    }
  };
}
function handleWherePair([field, filter], objectOrInterface) {
  !(filter != null) ? process.env.NODE_ENV !== "production" ? invariant(false, "Defined key values are only allowed when they are not undefined.") : invariant(false) : void 0;
  if (typeof filter === "string" || typeof filter === "number" || typeof filter === "boolean") {
    if (objectOrInterface.type === "interface") {
      const [objApiNamespace] = extractNamespace(objectOrInterface.apiName);
      const [fieldApiNamespace, fieldShortName] = extractNamespace(field);
      if (fieldApiNamespace == null && objApiNamespace != null) {
        field = `${objApiNamespace}.${fieldShortName}`;
      }
    }
    return {
      type: "eq",
      field,
      value: filter
    };
  }
  const keysOfFilter = Object.keys(filter);
  // If any of the keys start with `$` then they must be the only one.
  // e.g. `where({ name: { $eq: "foo", $ne: "bar" } })` is invalid currently
  const hasDollarSign = keysOfFilter.some(key => key.startsWith("$"));
  !(!hasDollarSign || keysOfFilter.length === 1) ? process.env.NODE_ENV !== "production" ? invariant(false, "WhereClause Filter with multiple clauses isn't allowed") : invariant(false) : void 0;
  if (!hasDollarSign) {
    // Future case for structs
    throw new Error(`Unsupported filter. Did you forget to use a $-prefixed filter? (${JSON.stringify(filter)})`);
  }
  const firstKey = keysOfFilter[0];
  !(filter[firstKey] != null) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
  if (firstKey === "$ne") {
    return {
      type: "not",
      value: {
        type: "eq",
        field,
        value: filter[firstKey]
      }
    };
  }
  if (firstKey === "$within") {
    const withinBody = filter[firstKey];
    if (Array.isArray(withinBody)) {
      return makeGeoFilterBbox(field, withinBody, firstKey);
    } else if ("$bbox" in withinBody && withinBody.$bbox != null) {
      return makeGeoFilterBbox(field, withinBody.$bbox, firstKey);
    } else if ("$distance" in withinBody && "$of" in withinBody && withinBody.$distance != null && withinBody.$of != null) {
      return {
        type: "withinDistanceOf",
        field,
        value: {
          center: Array.isArray(withinBody.$of) ? {
            type: "Point",
            coordinates: withinBody.$of
          } : withinBody.$of,
          distance: {
            value: withinBody.$distance[0],
            unit: DistanceUnitMapping[withinBody.$distance[1]]
          }
        }
      };
    } else {
      const coordinates = "$polygon" in withinBody ? withinBody.$polygon : withinBody.coordinates;
      return makeGeoFilterPolygon(field, coordinates, "withinPolygon");
    }
  }
  if (firstKey === "$intersects") {
    const intersectsBody = filter[firstKey];
    if (Array.isArray(intersectsBody)) {
      return makeGeoFilterBbox(field, intersectsBody, firstKey);
    } else if ("$bbox" in intersectsBody && intersectsBody.$bbox != null) {
      return makeGeoFilterBbox(field, intersectsBody.$bbox, firstKey);
    } else {
      const coordinates = "$polygon" in intersectsBody ? intersectsBody.$polygon : intersectsBody.coordinates;
      return makeGeoFilterPolygon(field, coordinates, "intersectsPolygon");
    }
  }
  return {
    type: firstKey.substring(1),
    field,
    value: filter[firstKey]
  };
}
//# sourceMappingURL=modernToLegacyWhereClause.js.map