{"version":3,"file":"streamutils.js","names":["START_TOKEN","Uint8Array","OBJECT_OPEN_CHAR_CODE","OBJECT_CLOSE_CHAR_CODE","parseStreamedResponse","asyncIterable","utf8decoder","TextDecoder","parsedStart","prevChunks","openBracesCount","chunk","i","startsWith","length","j","c","combineAndParse","subarray","push","a","b","prev","curr","str","decode","stream","JSON","parse","iterateReadableStream","readableStream","res","read","done","value"],"sources":["streamutils.js"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst START_TOKEN = new Uint8Array([123, 34, 100, 97, 116, 97, 34, 58, 91]); // `{\"data\":[`\nconst OBJECT_OPEN_CHAR_CODE = 123; // '{'\nconst OBJECT_CLOSE_CHAR_CODE = 125; // '}'\nexport async function* parseStreamedResponse(asyncIterable) {\n    const utf8decoder = new TextDecoder(\"utf-8\");\n    let parsedStart = false;\n    let prevChunks = [];\n    let openBracesCount = 0;\n    for await (let chunk of asyncIterable) {\n        // on the first chunk, skip the expected START_TOKEN if we see it\n        let i = 0;\n        if (!parsedStart) {\n            parsedStart = true;\n            if (startsWith(chunk, START_TOKEN)) {\n                i = START_TOKEN.length;\n            }\n        }\n        for (; i < chunk.length; i++) {\n            // if we aren't currently parsing an object, skip until we find the next object start\n            while (openBracesCount === 0 && chunk[i] !== OBJECT_OPEN_CHAR_CODE\n                && i < chunk.length) {\n                i++;\n            }\n            // iterate through the chunk looking for the end of the current top level object\n            let j = i;\n            for (; j < chunk.length; j++) {\n                const c = chunk[j];\n                if (c === OBJECT_OPEN_CHAR_CODE) {\n                    openBracesCount++;\n                }\n                else if (c === OBJECT_CLOSE_CHAR_CODE) {\n                    openBracesCount--;\n                    // found a complete top level object, emit it\n                    if (0 === openBracesCount) {\n                        yield combineAndParse(utf8decoder, prevChunks, chunk.subarray(i, j + 1));\n                        // if there was a prevChunk, we've consumed it now\n                        prevChunks = [];\n                        // advance the start index to the final '}' of the current object,\n                        // which lets us start seeking the beginning of the next object\n                        i = j;\n                        break;\n                    }\n                }\n            }\n            // if we reached the end of our chunk before finding the end of the object\n            // store off the relevant remainder of our current chunk and go grab the next one\n            if (j === chunk.length) {\n                prevChunks.push(chunk.subarray(i));\n                break;\n            }\n        }\n    }\n}\nfunction startsWith(a, b) {\n    if (a.length < b.length) {\n        return false;\n    }\n    for (let i = 0; i < b.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction combineAndParse(utf8decoder, prev, curr) {\n    let str = \"\";\n    for (const chunk of prev) {\n        str += utf8decoder.decode(chunk, { stream: true });\n    }\n    str += utf8decoder.decode(curr);\n    return JSON.parse(str);\n}\nexport async function* iterateReadableStream(readableStream) {\n    let res = await readableStream.read();\n    while (!res.done) {\n        yield res.value;\n        res = await readableStream.read();\n    }\n}\n"],"mappings":"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","ignoreList":[]}