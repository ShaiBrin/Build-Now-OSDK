{"version":3,"file":"modernToLegacyWhereClause.js","names":["DistanceUnitMapping","invariant","extractNamespace","fqApiName","last","lastIndexOf","undefined","slice","modernToLegacyWhereClause","whereClause","objectOrInterface","type","value","$and","map","clause","$or","$not","parts","Object","entries","length","handleWherePair","v","makeGeoFilterBbox","field","bbox","filterType","topLeft","coordinates","bottomRight","makeGeoFilterPolygon","filter","process","env","NODE_ENV","objApiNamespace","apiName","fieldApiNamespace","fieldShortName","keysOfFilter","keys","hasDollarSign","some","key","startsWith","Error","JSON","stringify","firstKey","withinBody","Array","isArray","$bbox","$distance","$of","center","distance","unit","$polygon","intersectsBody","substring"],"sources":["modernToLegacyWhereClause.js"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DistanceUnitMapping } from \"@osdk/api\";\nimport invariant from \"tiny-invariant\";\nexport function extractNamespace(fqApiName) {\n    const last = fqApiName.lastIndexOf(\".\");\n    if (last === -1)\n        return [undefined, fqApiName];\n    return [fqApiName.slice(0, last), fqApiName.slice(last + 1)];\n}\n/** @internal */\nexport function modernToLegacyWhereClause(whereClause, objectOrInterface) {\n    if (\"$and\" in whereClause) {\n        return {\n            type: \"and\",\n            value: whereClause.$and.map((clause) => modernToLegacyWhereClause(clause, objectOrInterface)),\n        };\n    }\n    else if (\"$or\" in whereClause) {\n        return {\n            type: \"or\",\n            value: whereClause.$or.map((clause) => modernToLegacyWhereClause(clause, objectOrInterface)),\n        };\n    }\n    else if (\"$not\" in whereClause) {\n        return {\n            type: \"not\",\n            value: modernToLegacyWhereClause(whereClause.$not, objectOrInterface),\n        };\n    }\n    const parts = Object.entries(whereClause);\n    if (parts.length === 1) {\n        return handleWherePair(parts[0], objectOrInterface);\n    }\n    return {\n        type: \"and\",\n        value: parts.map(v => handleWherePair(v, objectOrInterface)),\n    };\n}\nfunction makeGeoFilterBbox(field, bbox, filterType) {\n    return {\n        type: filterType === \"$within\"\n            ? \"withinBoundingBox\"\n            : \"intersectsBoundingBox\",\n        field,\n        value: {\n            topLeft: {\n                type: \"Point\",\n                coordinates: [bbox[0], bbox[3]],\n            },\n            bottomRight: {\n                type: \"Point\",\n                coordinates: [bbox[2], bbox[1]],\n            },\n        },\n    };\n}\nfunction makeGeoFilterPolygon(field, coordinates, filterType) {\n    return {\n        type: filterType,\n        field,\n        value: {\n            type: \"Polygon\",\n            coordinates,\n        },\n    };\n}\nfunction handleWherePair([field, filter], objectOrInterface) {\n    invariant(filter != null, \"Defined key values are only allowed when they are not undefined.\");\n    if (typeof filter === \"string\" || typeof filter === \"number\"\n        || typeof filter === \"boolean\") {\n        if (objectOrInterface.type === \"interface\") {\n            const [objApiNamespace] = extractNamespace(objectOrInterface.apiName);\n            const [fieldApiNamespace, fieldShortName] = extractNamespace(field);\n            if (fieldApiNamespace == null && objApiNamespace != null) {\n                field = `${objApiNamespace}.${fieldShortName}`;\n            }\n        }\n        return {\n            type: \"eq\",\n            field,\n            value: filter,\n        };\n    }\n    const keysOfFilter = Object.keys(filter);\n    // If any of the keys start with `$` then they must be the only one.\n    // e.g. `where({ name: { $eq: \"foo\", $ne: \"bar\" } })` is invalid currently\n    const hasDollarSign = keysOfFilter.some((key) => key.startsWith(\"$\"));\n    invariant(!hasDollarSign\n        || keysOfFilter.length === 1, \"WhereClause Filter with multiple clauses isn't allowed\");\n    if (!hasDollarSign) {\n        // Future case for structs\n        throw new Error(`Unsupported filter. Did you forget to use a $-prefixed filter? (${JSON.stringify(filter)})`);\n    }\n    const firstKey = keysOfFilter[0];\n    invariant(filter[firstKey] != null);\n    if (firstKey === \"$ne\") {\n        return {\n            type: \"not\",\n            value: {\n                type: \"eq\",\n                field,\n                value: filter[firstKey],\n            },\n        };\n    }\n    if (firstKey === \"$within\") {\n        const withinBody = filter[firstKey];\n        if (Array.isArray(withinBody)) {\n            return makeGeoFilterBbox(field, withinBody, firstKey);\n        }\n        else if (\"$bbox\" in withinBody && withinBody.$bbox != null) {\n            return makeGeoFilterBbox(field, withinBody.$bbox, firstKey);\n        }\n        else if ((\"$distance\" in withinBody && \"$of\" in withinBody)\n            && withinBody.$distance != null\n            && withinBody.$of != null) {\n            return {\n                type: \"withinDistanceOf\",\n                field,\n                value: {\n                    center: Array.isArray(withinBody.$of)\n                        ? {\n                            type: \"Point\",\n                            coordinates: withinBody.$of,\n                        }\n                        : withinBody.$of,\n                    distance: {\n                        value: withinBody.$distance[0],\n                        unit: DistanceUnitMapping[withinBody.$distance[1]],\n                    },\n                },\n            };\n        }\n        else {\n            const coordinates = (\"$polygon\" in withinBody)\n                ? withinBody.$polygon\n                : withinBody.coordinates;\n            return makeGeoFilterPolygon(field, coordinates, \"withinPolygon\");\n        }\n    }\n    if (firstKey === \"$intersects\") {\n        const intersectsBody = filter[firstKey];\n        if (Array.isArray(intersectsBody)) {\n            return makeGeoFilterBbox(field, intersectsBody, firstKey);\n        }\n        else if (\"$bbox\" in intersectsBody && intersectsBody.$bbox != null) {\n            return makeGeoFilterBbox(field, intersectsBody.$bbox, firstKey);\n        }\n        else {\n            const coordinates = (\"$polygon\" in intersectsBody)\n                ? intersectsBody.$polygon\n                : intersectsBody.coordinates;\n            return makeGeoFilterPolygon(field, coordinates, \"intersectsPolygon\");\n        }\n    }\n    return {\n        type: firstKey.substring(1),\n        field,\n        value: filter[firstKey],\n    };\n}\n"],"mappings":"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","ignoreList":[]}