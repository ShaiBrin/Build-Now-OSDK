"use strict";

async function conjureFetch(
  { fetchFn, baseUrl, servicePath, tokenProvider },
  url,
  method,
  body,
  params,
  contentType,
  accept,
) {
  if (body) {
    if (
      body instanceof URLSearchParams || body instanceof Blob || body instanceof FormData
      || typeof body === "string" || body instanceof ArrayBuffer
    );
    else {
      body = JSON.stringify(body);
    }
  }
  const queryParams = Object.entries(params ?? {}).flatMap(
    ([key, value]) => {
      if (value == null) {
        return [];
      }
      if (Array.isArray(value)) {
        return value.map((item) => [key, item]);
      }
      const stringValue = "" + value;
      return stringValue.length === 0 ? [] : [[key, stringValue]];
    },
  );
  const query = Object.keys(queryParams).length === 0
    ? ""
    : `?${new URLSearchParams(queryParams).toString()}`;
  const response = await (fetchFn ?? fetch)(`${baseUrl}${servicePath}${url}${query}`, {
    method,
    credentials: "same-origin",
    headers: {
      "Fetch-User-Agent": "conjure-lite",
      "Content-Type": contentType ?? "application/json",
      accept: accept ?? "application/json",
      ...tokenProvider ? { "Authorization": `Bearer ${await tokenProvider()}` } : {},
    },
    ...body ? { body } : {},
  });
  try {
    if (response.status === 204) {
      return void 0;
    }
    const body2 = await readBody(response);
    if (!response.ok) {
      throw new ConjureError("STATUS", void 0, response.status, body2);
    }
    return body2;
  } catch (error) {
    if (error instanceof ConjureError) {
      throw error;
    } else if (error instanceof TypeError) {
      throw new ConjureError("NETWORK", error);
    } else {
      throw new ConjureError("OTHER", error);
    }
  }
}
async function readBody(response) {
  const contentType = response.headers.get("Content-Type") != null
    ? response.headers.get("Content-Type")
    : "";
  try {
    if (contentType.includes("application/json")) {
      return await response.json();
    } else if (contentType.includes("application/octet-stream")) {
      return await response.blob();
    } else {
      return await response.text();
    }
  } catch (error) {
    throw new ConjureError("PARSE", error, response.status);
  }
}
class ConjureError {
  type;
  originalError;
  status;
  body;
  constructor(errorType, originalError, status, body) {
    this.type = errorType;
    this.originalError = originalError;
    this.status = status;
    this.body = body;
  }
  toString() {
    return JSON.stringify(
      {
        body: this.body,
        originalError: this.originalError && this.originalError.toString(),
        status: this.status,
        type: this.type,
      },
      null,
      "  ",
    );
  }
}

exports.conjureFetch = conjureFetch;
